/*

undefined
The base leg object with all fields, to be inherited

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as State_ from './components/state';
import * as Place_ from './components/place';
import * as Units_ from './components/units';
import * as t from 'io-ts';
import * as TravelMode_ from './components/travel-mode';
import * as Stop_ from './stop';
import * as UnitsGeo_ from './components/units-geo';
import * as Common_ from './components/common';
import * as BookingOption_ from './booking-option';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export interface DefinedC extends DefinedType {}
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'http://maasglobal.com/core/leg.json';

// State
// The purpose of this remains a mystery
export type State = State_.LegState;
// exists type StateC extends t.AnyC
export const State: StateC = State_.LegState;

// From
// The purpose of this remains a mystery
export type From = Place_.Place;
// exists type FromC extends t.AnyC
export const From: FromC = Place_.Place;

// To
// The purpose of this remains a mystery
export type To = Place_.Place;
// exists type ToC extends t.AnyC
export const To: ToC = Place_.Place;

// StartTime
// The purpose of this remains a mystery
export type StartTime = Units_.Time;
// exists type StartTimeC extends t.AnyC
export const StartTime: StartTimeC = Units_.Time;

// EndTime
// The purpose of this remains a mystery
export type EndTime = Units_.Time;
// exists type EndTimeC extends t.AnyC
export const EndTime: EndTimeC = Units_.Time;

// Mode
// The purpose of this remains a mystery
export type Mode = t.Branded<
  | TravelMode_.PersonalMode
  | TravelMode_.PublicTransitMode
  | TravelMode_.PrivateTransitMode,
  ModeBrand
>;
export type ModeC = t.BrandC<
  t.UnionC<
    [
      typeof TravelMode_.PersonalMode,
      typeof TravelMode_.PublicTransitMode,
      typeof TravelMode_.PrivateTransitMode,
    ]
  >,
  ModeBrand
>;
export const Mode: ModeC = t.brand(
  t.union([
    TravelMode_.PersonalMode,
    TravelMode_.PublicTransitMode,
    TravelMode_.PrivateTransitMode,
  ]),
  (
    x,
  ): x is t.Branded<
    | TravelMode_.PersonalMode
    | TravelMode_.PublicTransitMode
    | TravelMode_.PrivateTransitMode,
    ModeBrand
  > => true,
  'Mode',
);
export interface ModeBrand {
  readonly Mode: unique symbol;
}

// Stops
// The purpose of this remains a mystery
export type Stops = t.Branded<Array<Stop_.Stop>, StopsBrand>;
export type StopsC = t.BrandC<t.ArrayC<typeof Stop_.Stop>, StopsBrand>;
export const Stops: StopsC = t.brand(
  t.array(Stop_.Stop),
  (x): x is t.Branded<Array<Stop_.Stop>, StopsBrand> => true,
  'Stops',
);
export interface StopsBrand {
  readonly Stops: unique symbol;
}

// DepartureDelay
// The purpose of this remains a mystery
export type DepartureDelay = Units_.Duration;
// exists type DepartureDelayC extends t.AnyC
export const DepartureDelay: DepartureDelayC = Units_.Duration;

// ArrivalDelay
// The purpose of this remains a mystery
export type ArrivalDelay = Units_.Duration;
// exists type ArrivalDelayC extends t.AnyC
export const ArrivalDelay: ArrivalDelayC = Units_.Duration;

// Distance
// The purpose of this remains a mystery
export type Distance = UnitsGeo_.Distance;
// exists type DistanceC extends t.AnyC
export const Distance: DistanceC = UnitsGeo_.Distance;

// Route
// The purpose of this remains a mystery
export type Route = t.Branded<string, RouteBrand>;
export type RouteC = t.BrandC<t.StringC, RouteBrand>;
export const Route: RouteC = t.brand(
  t.string,
  (x): x is t.Branded<string, RouteBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 255),
  'Route',
);
export interface RouteBrand {
  readonly Route: unique symbol;
}

// RouteShortName
// The purpose of this remains a mystery
export type RouteShortName = t.Branded<string, RouteShortNameBrand>;
export type RouteShortNameC = t.BrandC<t.StringC, RouteShortNameBrand>;
export const RouteShortName: RouteShortNameC = t.brand(
  t.string,
  (x): x is t.Branded<string, RouteShortNameBrand> =>
    (typeof x !== 'string' || x.length >= 1) && (typeof x !== 'string' || x.length <= 64),
  'RouteShortName',
);
export interface RouteShortNameBrand {
  readonly RouteShortName: unique symbol;
}

// RouteLongName
// The purpose of this remains a mystery
export type RouteLongName = t.Branded<string, RouteLongNameBrand>;
export type RouteLongNameC = t.BrandC<t.StringC, RouteLongNameBrand>;
export const RouteLongName: RouteLongNameC = t.brand(
  t.string,
  (x): x is t.Branded<string, RouteLongNameBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 255),
  'RouteLongName',
);
export interface RouteLongNameBrand {
  readonly RouteLongName: unique symbol;
}

// AgencyId
// The purpose of this remains a mystery
export type AgencyId = Common_.AgencyId;
// exists type AgencyIdC extends t.AnyC
export const AgencyId: AgencyIdC = Common_.AgencyId;

// LegGeometry
// The purpose of this remains a mystery
export type LegGeometry = t.Branded<
  {
    points?: UnitsGeo_.Polyline;
  },
  LegGeometryBrand
>;
export type LegGeometryC = t.BrandC<
  t.PartialC<{
    points: typeof UnitsGeo_.Polyline;
  }>,
  LegGeometryBrand
>;
export const LegGeometry: LegGeometryC = t.brand(
  t.partial({
    points: UnitsGeo_.Polyline,
  }),
  (
    x,
  ): x is t.Branded<
    {
      points?: UnitsGeo_.Polyline;
    },
    LegGeometryBrand
  > => true,
  'LegGeometry',
);
export interface LegGeometryBrand {
  readonly LegGeometry: unique symbol;
}

// TspProduct
// The purpose of this remains a mystery
export type TspProduct = BookingOption_.TspProduct;
// exists type TspProductC extends t.AnyC
export const TspProduct: TspProductC = BookingOption_.TspProduct;

// ProductOption
// Index of the productOption used in the itinerary's productOptions
export type ProductOption = t.Branded<number, ProductOptionBrand>;
export type ProductOptionC = t.BrandC<t.NumberC, ProductOptionBrand>;
export const ProductOption: ProductOptionC = t.brand(
  t.number,
  (x): x is t.Branded<number, ProductOptionBrand> => Number.isInteger(x),
  'ProductOption',
);
export interface ProductOptionBrand {
  readonly ProductOption: unique symbol;
}

// LegExtensions
// MaaS specific leg extensions
export type LegExtensions = t.Branded<
  {
    id?: Units_.Uuid;
    signature?: Common_.Signature;
  },
  LegExtensionsBrand
>;
export type LegExtensionsC = t.BrandC<
  t.PartialC<{
    id: typeof Units_.Uuid;
    signature: typeof Common_.Signature;
  }>,
  LegExtensionsBrand
>;
export const LegExtensions: LegExtensionsC = t.brand(
  t.partial({
    id: Units_.Uuid,
    signature: Common_.Signature,
  }),
  (
    x,
  ): x is t.Branded<
    {
      id?: Units_.Uuid;
      signature?: Common_.Signature;
    },
    LegExtensionsBrand
  > => true,
  'LegExtensions',
);
export interface LegExtensionsBrand {
  readonly LegExtensions: unique symbol;
}

// LegCore
// The purpose of this remains a mystery
export type LegCore = t.Branded<
  {
    state?: State;
    from?: From;
    to?: To;
    startTime?: StartTime;
    endTime?: EndTime;
    mode?: Mode;
    stops?: Stops;
    departureDelay?: DepartureDelay;
    arrivalDelay?: ArrivalDelay;
    distance?: Distance;
    route?: Route;
    routeShortName?: RouteShortName;
    routeLongName?: RouteLongName;
    agencyId?: AgencyId;
    legGeometry?: LegGeometry;
    tspProduct?: TspProduct;
    productOption?: ProductOption;
  } & {
    from: Defined;
    to: Defined;
    mode: Defined;
    startTime: Defined;
    endTime: Defined;
    legGeometry: Defined;
  },
  LegCoreBrand
>;
export type LegCoreC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        state: typeof State;
        from: typeof From;
        to: typeof To;
        startTime: typeof StartTime;
        endTime: typeof EndTime;
        mode: typeof Mode;
        stops: typeof Stops;
        departureDelay: typeof DepartureDelay;
        arrivalDelay: typeof ArrivalDelay;
        distance: typeof Distance;
        route: typeof Route;
        routeShortName: typeof RouteShortName;
        routeLongName: typeof RouteLongName;
        agencyId: typeof AgencyId;
        legGeometry: typeof LegGeometry;
        tspProduct: typeof TspProduct;
        productOption: typeof ProductOption;
      }>,
      t.TypeC<{
        from: typeof Defined;
        to: typeof Defined;
        mode: typeof Defined;
        startTime: typeof Defined;
        endTime: typeof Defined;
        legGeometry: typeof Defined;
      }>,
    ]
  >,
  LegCoreBrand
>;
export const LegCore: LegCoreC = t.brand(
  t.intersection([
    t.partial({
      state: State,
      from: From,
      to: To,
      startTime: StartTime,
      endTime: EndTime,
      mode: Mode,
      stops: Stops,
      departureDelay: DepartureDelay,
      arrivalDelay: ArrivalDelay,
      distance: Distance,
      route: Route,
      routeShortName: RouteShortName,
      routeLongName: RouteLongName,
      agencyId: AgencyId,
      legGeometry: LegGeometry,
      tspProduct: TspProduct,
      productOption: ProductOption,
    }),
    t.type({
      from: Defined,
      to: Defined,
      mode: Defined,
      startTime: Defined,
      endTime: Defined,
      legGeometry: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      state?: State;
      from?: From;
      to?: To;
      startTime?: StartTime;
      endTime?: EndTime;
      mode?: Mode;
      stops?: Stops;
      departureDelay?: DepartureDelay;
      arrivalDelay?: ArrivalDelay;
      distance?: Distance;
      route?: Route;
      routeShortName?: RouteShortName;
      routeLongName?: RouteLongName;
      agencyId?: AgencyId;
      legGeometry?: LegGeometry;
      tspProduct?: TspProduct;
      productOption?: ProductOption;
    } & {
      from: Defined;
      to: Defined;
      mode: Defined;
      startTime: Defined;
      endTime: Defined;
      legGeometry: Defined;
    },
    LegCoreBrand
  > => true,
  'LegCore',
);
export interface LegCoreBrand {
  readonly LegCore: unique symbol;
}

// WaitingLeg
// The purpose of this remains a mystery
export type WaitingLeg = t.Branded<
  {
    startTime?: Units_.Time;
    endTime?: Units_.Time;
    mode?: TravelMode_.WaitingMode;
  } & {
    mode: Defined;
    startTime: Defined;
    endTime: Defined;
  },
  WaitingLegBrand
>;
export type WaitingLegC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        startTime: typeof Units_.Time;
        endTime: typeof Units_.Time;
        mode: typeof TravelMode_.WaitingMode;
      }>,
      t.TypeC<{
        mode: typeof Defined;
        startTime: typeof Defined;
        endTime: typeof Defined;
      }>,
    ]
  >,
  WaitingLegBrand
>;
export const WaitingLeg: WaitingLegC = t.brand(
  t.intersection([
    t.partial({
      startTime: Units_.Time,
      endTime: Units_.Time,
      mode: TravelMode_.WaitingMode,
    }),
    t.type({
      mode: Defined,
      startTime: Defined,
      endTime: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      startTime?: Units_.Time;
      endTime?: Units_.Time;
      mode?: TravelMode_.WaitingMode;
    } & {
      mode: Defined;
      startTime: Defined;
      endTime: Defined;
    },
    WaitingLegBrand
  > => true,
  'WaitingLeg',
);
export interface WaitingLegBrand {
  readonly WaitingLeg: unique symbol;
}

// TransferLeg
// The purpose of this remains a mystery
export type TransferLeg = t.Branded<
  {
    startTime?: Units_.Time;
    endTime?: Units_.Time;
    mode?: TravelMode_.TransferMode;
  } & {
    mode: Defined;
    startTime: Defined;
    endTime: Defined;
  },
  TransferLegBrand
>;
export type TransferLegC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        startTime: typeof Units_.Time;
        endTime: typeof Units_.Time;
        mode: typeof TravelMode_.TransferMode;
      }>,
      t.TypeC<{
        mode: typeof Defined;
        startTime: typeof Defined;
        endTime: typeof Defined;
      }>,
    ]
  >,
  TransferLegBrand
>;
export const TransferLeg: TransferLegC = t.brand(
  t.intersection([
    t.partial({
      startTime: Units_.Time,
      endTime: Units_.Time,
      mode: TravelMode_.TransferMode,
    }),
    t.type({
      mode: Defined,
      startTime: Defined,
      endTime: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      startTime?: Units_.Time;
      endTime?: Units_.Time;
      mode?: TravelMode_.TransferMode;
    } & {
      mode: Defined;
      startTime: Defined;
      endTime: Defined;
    },
    TransferLegBrand
  > => true,
  'TransferLeg',
);
export interface TransferLegBrand {
  readonly TransferLeg: unique symbol;
}

// Leg
// The default export. More information at the top.
export type Leg = t.Branded<
  {} & (LegExtensions & (LegCore | WaitingLeg | TransferLeg)),
  LegBrand
>;
export type LegC = t.BrandC<
  t.IntersectionC<
    [
      t.TypeC<{}>,
      t.IntersectionC<
        [
          typeof LegExtensions,
          t.UnionC<[typeof LegCore, typeof WaitingLeg, typeof TransferLeg]>,
        ]
      >,
    ]
  >,
  LegBrand
>;
export const Leg: LegC = t.brand(
  t.intersection([
    t.type({}),
    t.intersection([LegExtensions, t.union([LegCore, WaitingLeg, TransferLeg])]),
  ]),
  (
    x,
  ): x is t.Branded<
    {} & (LegExtensions & (LegCore | WaitingLeg | TransferLeg)),
    LegBrand
  > => true,
  'Leg',
);
export interface LegBrand {
  readonly Leg: unique symbol;
}

export type StateC = State_.LegStateC;
export type FromC = Place_.PlaceC;
export type ToC = Place_.PlaceC;
export type StartTimeC = Units_.TimeC;
export type EndTimeC = Units_.TimeC;
export type DepartureDelayC = Units_.DurationC;
export type ArrivalDelayC = Units_.DurationC;
export type DistanceC = UnitsGeo_.DistanceC;
export type AgencyIdC = Common_.AgencyIdC;
export type TspProductC = BookingOption_.TspProductC;
export default Leg;

// Success
