/*

undefined
MaaS station schemas

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import * as UnitsGeo_ from './units-geo';
import * as Address_ from './address';
import * as Common_ from './common';
import * as TravelMode_ from './travel-mode';
import * as Units_ from './units';

export const schemaId = 'http://maasglobal.com/core/components/station.json';

// Id
// The purpose of this remains a mystery
export type Id = t.Branded<string, IdBrand>;
export type IdC = t.BrandC<t.StringC, IdBrand>;
export const Id: IdC = t.brand(
  t.string,
  (x): x is t.Branded<string, IdBrand> =>
    (typeof x !== 'string' || x.length >= 1) && (typeof x !== 'string' || x.length <= 64),
  'Id',
);
export interface IdBrand {
  readonly Id: unique symbol;
}

// Code
// The purpose of this remains a mystery
export type Code = t.Branded<string, CodeBrand>;
export type CodeC = t.BrandC<t.StringC, CodeBrand>;
export const Code: CodeC = t.brand(
  t.string,
  (x): x is t.Branded<string, CodeBrand> => true,
  'Code',
);
export interface CodeBrand {
  readonly Code: unique symbol;
}

// Name
// The purpose of this remains a mystery
export type Name = t.Branded<string, NameBrand>;
export type NameC = t.BrandC<t.StringC, NameBrand>;
export const Name: NameC = t.brand(
  t.string,
  (x): x is t.Branded<string, NameBrand> => true,
  'Name',
);
export interface NameBrand {
  readonly Name: unique symbol;
}

// Location
// The purpose of this remains a mystery
export type Location = UnitsGeo_.ShortLocationString;
// exists type LocationC extends t.AnyC
export const Location: LocationC = UnitsGeo_.ShortLocationString;

// Address
// The purpose of this remains a mystery
export type Address = Address_.Address;
// exists type AddressC extends t.AnyC
export const Address: AddressC = Address_.Address;

// City
// The purpose of this remains a mystery
export type City = Address_.City;
// exists type CityC extends t.AnyC
export const City: CityC = Address_.City;

// Country
// The purpose of this remains a mystery
export type Country = Address_.Country;
// exists type CountryC extends t.AnyC
export const Country: CountryC = Address_.Country;

// AgencyId
// The purpose of this remains a mystery
export type AgencyId = Common_.AgencyId;
// exists type AgencyIdC extends t.AnyC
export const AgencyId: AgencyIdC = Common_.AgencyId;

// OpeningHours
// Opening hour of the station, object format is left for TSP to decide
export type OpeningHours = t.Branded<{}, OpeningHoursBrand>;
export type OpeningHoursC = t.BrandC<t.TypeC<{}>, OpeningHoursBrand>;
export const OpeningHours: OpeningHoursC = t.brand(
  t.type({}),
  (x): x is t.Branded<{}, OpeningHoursBrand> => true,
  'OpeningHours',
);
export interface OpeningHoursBrand {
  readonly OpeningHours: unique symbol;
}

// Facilities
// Station facilities, including services and features
export type Facilities = t.Branded<Array<string>, FacilitiesBrand>;
export type FacilitiesC = t.BrandC<t.ArrayC<t.StringC>, FacilitiesBrand>;
export const Facilities: FacilitiesC = t.brand(
  t.array(t.string),
  (x): x is t.Branded<Array<string>, FacilitiesBrand> => true,
  'Facilities',
);
export interface FacilitiesBrand {
  readonly Facilities: unique symbol;
}

// Services
// What agency and mode of transport will occupy this station
export type Services = t.Branded<Array<TravelMode_.TravelMode>, ServicesBrand>;
export type ServicesC = t.BrandC<t.ArrayC<typeof TravelMode_.TravelMode>, ServicesBrand>;
export const Services: ServicesC = t.brand(
  t.array(TravelMode_.TravelMode),
  (x): x is t.Branded<Array<TravelMode_.TravelMode>, ServicesBrand> => true,
  'Services',
);
export interface ServicesBrand {
  readonly Services: unique symbol;
}

// Timetables
// Timetable for passing by / originating transports
export type Timetables = t.Branded<
  Array<{
    id?: string;
    mode?: TravelMode_.TravelMode;
    name?: string;
    longName?: string;
    schedule?: Units_.Time;
    realtime?: Units_.Time;
    isRealtime?: boolean;
  }>,
  TimetablesBrand
>;
export type TimetablesC = t.BrandC<
  t.ArrayC<
    t.PartialC<{
      id: t.StringC;
      mode: typeof TravelMode_.TravelMode;
      name: t.StringC;
      longName: t.StringC;
      schedule: typeof Units_.Time;
      realtime: typeof Units_.Time;
      isRealtime: t.BooleanC;
    }>
  >,
  TimetablesBrand
>;
export const Timetables: TimetablesC = t.brand(
  t.array(
    t.partial({
      id: t.string,
      mode: TravelMode_.TravelMode,
      name: t.string,
      longName: t.string,
      schedule: Units_.Time,
      realtime: Units_.Time,
      isRealtime: t.boolean,
    }),
  ),
  (
    x,
  ): x is t.Branded<
    Array<{
      id?: string;
      mode?: TravelMode_.TravelMode;
      name?: string;
      longName?: string;
      schedule?: Units_.Time;
      realtime?: Units_.Time;
      isRealtime?: boolean;
    }>,
    TimetablesBrand
  > => true,
  'Timetables',
);
export interface TimetablesBrand {
  readonly Timetables: unique symbol;
}

// Zone
// Geofencing zone defined by provider that the station is within
export type Zone = t.Branded<number | string, ZoneBrand>;
export type ZoneC = t.BrandC<t.UnionC<[t.NumberC, t.StringC]>, ZoneBrand>;
export const Zone: ZoneC = t.brand(
  t.union([t.number, t.string]),
  (x): x is t.Branded<number | string, ZoneBrand> => true,
  'Zone',
);
export interface ZoneBrand {
  readonly Zone: unique symbol;
}

// PlatformCode
// Platform number
export type PlatformCode = t.Branded<number | string, PlatformCodeBrand>;
export type PlatformCodeC = t.BrandC<t.UnionC<[t.NumberC, t.StringC]>, PlatformCodeBrand>;
export const PlatformCode: PlatformCodeC = t.brand(
  t.union([t.number, t.string]),
  (x): x is t.Branded<number | string, PlatformCodeBrand> => true,
  'PlatformCode',
);
export interface PlatformCodeBrand {
  readonly PlatformCode: unique symbol;
}

// Station
// The default export. More information at the top.
export type Station = t.Branded<{}, StationBrand>;
export type StationC = t.BrandC<t.TypeC<{}>, StationBrand>;
export const Station: StationC = t.brand(
  t.type({}),
  (x): x is t.Branded<{}, StationBrand> => true,
  'Station',
);
export interface StationBrand {
  readonly Station: unique symbol;
}

export type LocationC = UnitsGeo_.ShortLocationStringC;
export type AddressC = Address_.AddressC;
export type CityC = Address_.CityC;
export type CountryC = Address_.CountryC;
export type AgencyIdC = Common_.AgencyIdC;
export default Station;

// Success
